Find the total number of components by traversing over each node from 1 to n, and whenever you encounter an unvisited node, 
do a dfs to visit all nodes in its connected component and consider it as the representative of its connected component.
To link all connected components with minimal number of added edges, fix a connected component and add edges from its
representative element to all other representative elements.


#include<bits/stdc++.h>
using namespace std;

void dfs(int u, vector<set<int>>& adj, vector<bool>& visited) {
    visited[u] = true;
    for (int v : adj[u]) {
        if (!visited[v]) {
            dfs(v, adj, visited);
        }
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);   
    int n, m;
    cin >> n >> m;
    vector<set<int>> adj(n);
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--;
        adj[u].insert(v);
        adj[v].insert(u);
    }
    vector<bool> visited(n, false);
    int components = 0;
    vector<int> representative;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i, adj, visited);
            components++;
            representative.push_back(i + 1); 
        }
    }
    cout << components - 1 << "\n";
    for (int i = 1; i < representative.size(); i++) {
        int rep = representative[i];
        cout << representative[0] << " " << rep << "\n";
    }
    cout << "\n";
    return 0;
}
